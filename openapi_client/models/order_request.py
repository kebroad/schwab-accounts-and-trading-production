# coding: utf-8

"""
    Trader API - Account Access and User Preferences

    Schwab Trader API access to Account, Order entry and User Preferences

    The version of the OpenAPI document: 1.0.0
    Contact: TraderAPI@Schwab.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.complex_order_strategy_type import ComplexOrderStrategyType
from openapi_client.models.duration import Duration
from openapi_client.models.order_activity import OrderActivity
from openapi_client.models.order_leg_collection import OrderLegCollection
from openapi_client.models.order_strategy_type import OrderStrategyType
from openapi_client.models.order_type_request import OrderTypeRequest
from openapi_client.models.price_link_basis import PriceLinkBasis
from openapi_client.models.price_link_type import PriceLinkType
from openapi_client.models.session import Session
from openapi_client.models.special_instruction import SpecialInstruction
from openapi_client.models.status import Status
from openapi_client.models.stop_price_link_basis import StopPriceLinkBasis
from openapi_client.models.stop_price_link_type import StopPriceLinkType
from openapi_client.models.stop_type import StopType
from openapi_client.models.tax_lot_method import TaxLotMethod
from typing import Optional, Set
from typing_extensions import Self

class OrderRequest(BaseModel):
    """
    OrderRequest
    """ # noqa: E501
    session: Optional[Session] = None
    duration: Optional[Duration] = None
    order_type: Optional[OrderTypeRequest] = Field(default=None, alias="orderType")
    cancel_time: Optional[datetime] = Field(default=None, alias="cancelTime")
    complex_order_strategy_type: Optional[ComplexOrderStrategyType] = Field(default=None, alias="complexOrderStrategyType")
    quantity: Optional[Union[StrictFloat, StrictInt]] = None
    filled_quantity: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="filledQuantity")
    remaining_quantity: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="remainingQuantity")
    destination_link_name: Optional[StrictStr] = Field(default=None, alias="destinationLinkName")
    release_time: Optional[datetime] = Field(default=None, alias="releaseTime")
    stop_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="stopPrice")
    stop_price_link_basis: Optional[StopPriceLinkBasis] = Field(default=None, alias="stopPriceLinkBasis")
    stop_price_link_type: Optional[StopPriceLinkType] = Field(default=None, alias="stopPriceLinkType")
    stop_price_offset: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="stopPriceOffset")
    stop_type: Optional[StopType] = Field(default=None, alias="stopType")
    price_link_basis: Optional[PriceLinkBasis] = Field(default=None, alias="priceLinkBasis")
    price_link_type: Optional[PriceLinkType] = Field(default=None, alias="priceLinkType")
    price: Optional[Union[StrictFloat, StrictInt]] = None
    tax_lot_method: Optional[TaxLotMethod] = Field(default=None, alias="taxLotMethod")
    order_leg_collection: Optional[List[OrderLegCollection]] = Field(default=None, alias="orderLegCollection")
    activation_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="activationPrice")
    special_instruction: Optional[SpecialInstruction] = Field(default=None, alias="specialInstruction")
    order_strategy_type: Optional[OrderStrategyType] = Field(default=None, alias="orderStrategyType")
    order_id: Optional[StrictInt] = Field(default=None, alias="orderId")
    cancelable: Optional[StrictBool] = False
    editable: Optional[StrictBool] = False
    status: Optional[Status] = None
    entered_time: Optional[datetime] = Field(default=None, alias="enteredTime")
    close_time: Optional[datetime] = Field(default=None, alias="closeTime")
    account_number: Optional[StrictInt] = Field(default=None, alias="accountNumber")
    order_activity_collection: Optional[List[OrderActivity]] = Field(default=None, alias="orderActivityCollection")
    replacing_order_collection: Optional[List[OrderRequest]] = Field(default=None, alias="replacingOrderCollection")
    child_order_strategies: Optional[List[OrderRequest]] = Field(default=None, alias="childOrderStrategies")
    status_description: Optional[StrictStr] = Field(default=None, alias="statusDescription")
    __properties: ClassVar[List[str]] = ["session", "duration", "orderType", "cancelTime", "complexOrderStrategyType", "quantity", "filledQuantity", "remainingQuantity", "destinationLinkName", "releaseTime", "stopPrice", "stopPriceLinkBasis", "stopPriceLinkType", "stopPriceOffset", "stopType", "priceLinkBasis", "priceLinkType", "price", "taxLotMethod", "orderLegCollection", "activationPrice", "specialInstruction", "orderStrategyType", "orderId", "cancelable", "editable", "status", "enteredTime", "closeTime", "accountNumber", "orderActivityCollection", "replacingOrderCollection", "childOrderStrategies", "statusDescription"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in order_leg_collection (list)
        _items = []
        if self.order_leg_collection:
            for _item_order_leg_collection in self.order_leg_collection:
                if _item_order_leg_collection:
                    _items.append(_item_order_leg_collection.to_dict())
            _dict['orderLegCollection'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in order_activity_collection (list)
        _items = []
        if self.order_activity_collection:
            for _item_order_activity_collection in self.order_activity_collection:
                if _item_order_activity_collection:
                    _items.append(_item_order_activity_collection.to_dict())
            _dict['orderActivityCollection'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in replacing_order_collection (list)
        _items = []
        if self.replacing_order_collection:
            for _item_replacing_order_collection in self.replacing_order_collection:
                if _item_replacing_order_collection:
                    _items.append(_item_replacing_order_collection.to_dict())
            _dict['replacingOrderCollection'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in child_order_strategies (list)
        _items = []
        if self.child_order_strategies:
            for _item_child_order_strategies in self.child_order_strategies:
                if _item_child_order_strategies:
                    _items.append(_item_child_order_strategies.to_dict())
            _dict['childOrderStrategies'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "session": obj.get("session"),
            "duration": obj.get("duration"),
            "orderType": obj.get("orderType"),
            "cancelTime": obj.get("cancelTime"),
            "complexOrderStrategyType": obj.get("complexOrderStrategyType"),
            "quantity": obj.get("quantity"),
            "filledQuantity": obj.get("filledQuantity"),
            "remainingQuantity": obj.get("remainingQuantity"),
            "destinationLinkName": obj.get("destinationLinkName"),
            "releaseTime": obj.get("releaseTime"),
            "stopPrice": obj.get("stopPrice"),
            "stopPriceLinkBasis": obj.get("stopPriceLinkBasis"),
            "stopPriceLinkType": obj.get("stopPriceLinkType"),
            "stopPriceOffset": obj.get("stopPriceOffset"),
            "stopType": obj.get("stopType"),
            "priceLinkBasis": obj.get("priceLinkBasis"),
            "priceLinkType": obj.get("priceLinkType"),
            "price": obj.get("price"),
            "taxLotMethod": obj.get("taxLotMethod"),
            "orderLegCollection": [OrderLegCollection.from_dict(_item) for _item in obj["orderLegCollection"]] if obj.get("orderLegCollection") is not None else None,
            "activationPrice": obj.get("activationPrice"),
            "specialInstruction": obj.get("specialInstruction"),
            "orderStrategyType": obj.get("orderStrategyType"),
            "orderId": obj.get("orderId"),
            "cancelable": obj.get("cancelable") if obj.get("cancelable") is not None else False,
            "editable": obj.get("editable") if obj.get("editable") is not None else False,
            "status": obj.get("status"),
            "enteredTime": obj.get("enteredTime"),
            "closeTime": obj.get("closeTime"),
            "accountNumber": obj.get("accountNumber"),
            "orderActivityCollection": [OrderActivity.from_dict(_item) for _item in obj["orderActivityCollection"]] if obj.get("orderActivityCollection") is not None else None,
            "replacingOrderCollection": [OrderRequest.from_dict(_item) for _item in obj["replacingOrderCollection"]] if obj.get("replacingOrderCollection") is not None else None,
            "childOrderStrategies": [OrderRequest.from_dict(_item) for _item in obj["childOrderStrategies"]] if obj.get("childOrderStrategies") is not None else None,
            "statusDescription": obj.get("statusDescription")
        })
        return _obj

# TODO: Rewrite to not use raise_errors
OrderRequest.model_rebuild(raise_errors=False)

